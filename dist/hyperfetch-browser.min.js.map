{"version":3,"file":"hyperfetch-browser.min.js","mappings":"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","sources":["webpack://hypf/webpack/universalModuleDefinition","webpack://hypf/webpack/bootstrap","webpack://hypf/webpack/runtime/define property getters","webpack://hypf/webpack/runtime/hasOwnProperty shorthand","webpack://hypf/webpack/runtime/make namespace object","webpack://hypf/./src/constant.ts","webpack://hypf/./src/Hyperfetch.ts","webpack://hypf/./src/utils/append-params.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hypf\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hypf\"] = factory();\n\telse\n\t\troot[\"hypf\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Default maximum recommended timeout in milliseconds (adjust as needed)\r\nexport const DEFAULT_MAX_TIMEOUT = 2147483647;\r\n\r\nexport const DEFAULT_BACKOFF_FACTOR = 0.3;\r\nexport const DEFAULT_JITTER_FACTOR = 1;\r\n\r\nexport const isAbortControllerSupported =\r\n  typeof globalThis.AbortController === \"function\";\r\nexport const isReadableStreamSupported =\r\n  typeof globalThis.ReadableStream === \"function\";\r\nexport const isWriteableStreamSupported =\r\n  typeof globalThis.WritableStream === \"function\";\r\nexport const isWebsocketSupported = typeof globalThis.WebSocket === \"function\";\r\nexport const isWebRTCSupported =\r\n  typeof globalThis.RTCPeerConnection === \"function\";\r\nexport const isFormDataSupported = typeof globalThis.FormData === \"function\";\r\nexport const isNode =\r\n  typeof process !== \"undefined\" && process.release.name === \"node\";\r\n","import type {\r\n  HttpRequestFunctions,\r\n  RequestFunction,\r\n  RequestOptions,\r\n  HttpMethodFunction,\r\n} from \"./types/request.ts\";\r\nimport type { Hooks } from \"./types/hooks.ts\";\r\n\r\nimport {\r\n  DEFAULT_BACKOFF_FACTOR,\r\n  DEFAULT_JITTER_FACTOR,\r\n  DEFAULT_MAX_TIMEOUT,\r\n  isAbortControllerSupported,\r\n  isReadableStreamSupported,\r\n  isWriteableStreamSupported,\r\n  isWebRTCSupported,\r\n  isWebsocketSupported,\r\n  isNode,\r\n} from \"./constant.js\";\r\n\r\nimport { appendParams } from \"./utils/append-params.js\";\r\n\r\nconst defaultBackoff = (retryCount: number, factor: number) =>\r\n  Math.pow(2, retryCount) * 1000 * factor; // Exponential backoff, starting from 1 second\r\n\r\nconst defaultJitter = (factor: number) => Math.random() * 1000 * factor; // Randomized delay up to 1 second\r\n\r\n// Expose the AbortController instance through the library interface\r\nconst getAbortController = () =>\r\n  isAbortControllerSupported ? globalThis.abortController : null;\r\n\r\nfunction createRequest(\r\n  baseUrl?: string,\r\n  hooks?: Hooks,\r\n  DEBUG = false\r\n): HttpRequestFunctions {\r\n  // Check if fetch is available (browser environment)\r\n  if (typeof fetch === \"undefined\") {\r\n    throw new Error(\r\n      \"This library is intended for use in the browser environment only.\"\r\n    );\r\n  }\r\n\r\n  const request: RequestFunction = async (\r\n    url = \"\",\r\n    options = {},\r\n    data\r\n  ): Promise<[Error | null, null]> => {\r\n    try {\r\n      // Execute pre-request hook\r\n      if (hooks?.preRequest) {\r\n        hooks.preRequest(url, options);\r\n      }\r\n\r\n      const fullUrl = `${baseUrl}${url}`;\r\n      const {\r\n        method = \"GET\",\r\n        retries = 0,\r\n        backoff = defaultBackoff,\r\n        jitter = false,\r\n        jitterFactor = DEFAULT_JITTER_FACTOR,\r\n        backoffFactor = DEFAULT_BACKOFF_FACTOR,\r\n        timeout = DEFAULT_MAX_TIMEOUT,\r\n        retryOnTimeout = false,\r\n        params,\r\n        headers = {},\r\n        signal,\r\n        ...otherOptions\r\n      } = options;\r\n\r\n      const reqHeaders = new Headers(options.headers);\r\n\r\n      // Set default Content-Type to application/json if not provided\r\n      if (!reqHeaders.get(\"Content-Type\") && data && typeof data === \"object\") {\r\n        reqHeaders.set(\"Content-Type\", \"application/json\");\r\n      }\r\n\r\n      // Automatically detect and add Content-Length based on payload length\r\n      const textEncoder = new TextEncoder();\r\n      if (!reqHeaders.get(\"Content-Length\") && data) {\r\n        if (typeof data === \"string\") {\r\n          reqHeaders.set(\r\n            \"Content-Length\",\r\n            String(textEncoder.encode(data).length)\r\n          );\r\n        } else if (\r\n          reqHeaders.get(\"Content-Length\")?.includes(\"application/json\")\r\n        ) {\r\n          reqHeaders.set(\r\n            \"Content-Length\",\r\n            String(textEncoder.encode(JSON.stringify(data)).length)\r\n          );\r\n        }\r\n      }\r\n\r\n      // Execute pre-timeout hook\r\n      if (hooks?.preTimeout) {\r\n        hooks.preTimeout(url, options);\r\n      }\r\n\r\n      if (isAbortControllerSupported) {\r\n        // Expose the AbortController instance\r\n        globalThis.abortController = new AbortController();\r\n\r\n        // Use the external AbortController instance\r\n        globalThis.abortSignal = signal\r\n          ? signal\r\n          : globalThis.abortController.signal;\r\n      }\r\n\r\n      const timeoutId =\r\n        timeout && isAbortControllerSupported\r\n          ? setTimeout(() => {\r\n              globalThis.abortController.abort();\r\n\r\n              // Execute post-timeout hook\r\n              if (hooks?.postTimeout) {\r\n                hooks.postTimeout(url, options);\r\n              }\r\n            }, timeout)\r\n          : undefined;\r\n\r\n      // Append params to the URL\r\n      const urlWithParams = params ? appendParams(fullUrl, params) : fullUrl;\r\n\r\n      // Only checks Node.js for duplex compability, as other JS runtimes do full-duplex\r\n      // Streams are supported, but they inherently support one-way operations each. Combine them for pseudo full duplex.\r\n      if (isReadableStreamSupported && !isWriteableStreamSupported && isNode) {\r\n        // The @ts-expect-error directive is used here because we are about to assign a value to a property\r\n        // that might not be officially recognized in the TypeScript types definitions for `otherOptions`.\r\n        // This tells TypeScript to expect a type error on the next line but to ignore it for compilation.\r\n        // This approach is often used when dealing with dynamic properties or when using features that TypeScript\r\n        // is not aware of, possibly due to using newer browser APIs or experimental features.\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      if (!isReadableStreamSupported && isWriteableStreamSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      if (isReadableStreamSupported && isWriteableStreamSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      // WebRTC is supported, allowing for full duplex communication.\r\n      if (isWebRTCSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      // WebSockets are supported, and thus full duplex communication is possible.\r\n      if (isWebsocketSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n\r\n      const responsePromise = fetch(urlWithParams, {\r\n        method,\r\n        signal: isAbortControllerSupported ? globalThis.abortSignal : null,\r\n        headers,\r\n        ...otherOptions,\r\n        body: data ? JSON.stringify(data) : undefined,\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      const response = await responsePromise;\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Network response was not ok: ${response.status}`);\r\n      }\r\n\r\n      const contentType = response.headers.get(\"content-type\");\r\n      const responseData =\r\n        contentType && contentType.includes(\"application/json\")\r\n          ? await response.json()\r\n          : await response.text();\r\n\r\n      // Execute post-request hook\r\n      if (hooks?.postRequest) {\r\n        hooks.postRequest(url, options, data, [null, responseData]);\r\n      }\r\n\r\n      return [null, responseData];\r\n    } catch (error) {\r\n      // Execute post-request hook for errors\r\n      if (hooks?.postRequest) {\r\n        if (error instanceof Error) {\r\n          hooks.postRequest(url, options, data, [error, null]);\r\n        }\r\n      }\r\n\r\n      if (error instanceof Error) {\r\n        if (error.name === \"AbortError\") {\r\n          console.error(\"Request aborted:\", error);\r\n        } else if (\r\n          options.retryOnTimeout &&\r\n          error.name === \"TimeoutError\" &&\r\n          options.retries &&\r\n          options.retries > 0\r\n        ) {\r\n          const delay =\r\n            options.jitter && options.jitterFactor\r\n              ? defaultJitter(options.jitterFactor)\r\n              : defaultBackoff(\r\n                  options.retries,\r\n                  options.backoffFactor\r\n                    ? options.backoffFactor\r\n                    : DEFAULT_BACKOFF_FACTOR\r\n                );\r\n          if (DEBUG) {\r\n            console.warn(\r\n              `Request timed out. Retrying in ${delay}ms... (Remaining retries: ${options.retries})`\r\n            );\r\n          }\r\n          // Execute pre-retry hook\r\n          if (hooks?.preRetry) {\r\n            hooks.preRetry(url, options, options.retries, options.retries);\r\n          }\r\n          await new Promise((resolve) => setTimeout(resolve, delay));\r\n          const [retryErr, retryData] = await request(\r\n            url,\r\n            { ...options, retries: options.retries - 1 },\r\n            data\r\n          );\r\n          // Execute post-retry hook\r\n          if (hooks?.postRetry) {\r\n            hooks.postRetry(\r\n              url,\r\n              options,\r\n              data,\r\n              [retryErr, retryData],\r\n              options.retries,\r\n              options.retries - 1\r\n            );\r\n          }\r\n          return [retryErr, retryData];\r\n        } else if (options.retries && options.retries > 0) {\r\n          const delay =\r\n            options.jitter && options.jitterFactor\r\n              ? defaultJitter(options.jitterFactor)\r\n              : defaultBackoff(\r\n                  options.retries,\r\n                  options.backoffFactor\r\n                    ? options.backoffFactor\r\n                    : DEFAULT_BACKOFF_FACTOR\r\n                );\r\n          if (DEBUG) {\r\n            console.warn(\r\n              `Request failed. Retrying in ${delay}ms... (Remaining retries: ${options.retries})`\r\n            );\r\n          }\r\n          // Execute pre-retry hook\r\n          if (hooks?.preRetry) {\r\n            hooks.preRetry(url, options, options.retries, options.retries);\r\n          }\r\n          await new Promise((resolve) => setTimeout(resolve, delay));\r\n          const [retryErr, retryData] = await request(\r\n            url,\r\n            { ...options, retries: options.retries - 1 },\r\n            data\r\n          );\r\n          // Execute post-retry hook\r\n          if (hooks?.postRetry) {\r\n            hooks.postRetry(\r\n              url,\r\n              options,\r\n              data,\r\n              [retryErr, retryData],\r\n              options.retries,\r\n              options.retries - 1\r\n            );\r\n          }\r\n          return [retryErr, retryData];\r\n        }\r\n      }\r\n\r\n      if (error instanceof Error) {\r\n        return [error, null];\r\n      }\r\n\r\n      return [null, null];\r\n    }\r\n  };\r\n\r\n  const httpMethodFunction: HttpMethodFunction =\r\n    (url: string, options: RequestOptions = {}) =>\r\n    (method = \"GET\", additionalOptions = {}, data) => {\r\n      return request(url, { method, ...options, ...additionalOptions }, data);\r\n    };\r\n\r\n  return {\r\n    get: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"GET\", options, data),\r\n    post: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"POST\", options, data),\r\n    put: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"PUT\", options, data),\r\n    delete: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"DELETE\", options, data),\r\n    patch: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"PATCH\", options, data),\r\n    options: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"OPTIONS\", options, data),\r\n    getAbortController,\r\n  };\r\n}\r\n\r\nexport default { createRequest };\r\n","export function appendParams(\r\n  url: string,\r\n  params?: Record<string, string | number>\r\n): string {\r\n  if (!params) return url;\r\n\r\n  const urlWithParams = new URL(url);\r\n  Object.entries(params).forEach(([key, value]) =>\r\n    urlWithParams.searchParams.append(key, String(value))\r\n  );\r\n\r\n  return urlWithParams.toString();\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","DEFAULT_MAX_TIMEOUT","DEFAULT_BACKOFF_FACTOR","DEFAULT_JITTER_FACTOR","isAbortControllerSupported","globalThis","AbortController","isReadableStreamSupported","ReadableStream","isWriteableStreamSupported","WritableStream","isWebsocketSupported","WebSocket","isWebRTCSupported","RTCPeerConnection","isNode","FormData","process","release","name","defaultBackoff","retryCount","factor","Math","pow","defaultJitter","random","getAbortController","abortController","createRequest","baseUrl","hooks","DEBUG","fetch","Error","request","url","options","data","preRequest","fullUrl","method","retries","backoff","jitter","jitterFactor","backoffFactor","timeout","retryOnTimeout","params","headers","signal","otherOptions","reqHeaders","Headers","set","textEncoder","TextEncoder","String","encode","length","includes","JSON","stringify","preTimeout","abortSignal","timeoutId","setTimeout","abort","postTimeout","undefined","urlWithParams","URL","entries","forEach","searchParams","append","toString","appendParams","duplex","responsePromise","body","clearTimeout","response","ok","status","contentType","responseData","json","text","postRequest","error","console","delay","warn","preRetry","Promise","resolve","retryErr","retryData","postRetry","httpMethodFunction","additionalOptions","post","put","delete","patch"],"sourceRoot":""}