{"version":3,"file":"hyperfetch-browser.min.js","mappings":"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","sources":["webpack://hypf/webpack/universalModuleDefinition","webpack://hypf/webpack/bootstrap","webpack://hypf/webpack/runtime/define property getters","webpack://hypf/webpack/runtime/hasOwnProperty shorthand","webpack://hypf/webpack/runtime/make namespace object","webpack://hypf/./src/constant.ts","webpack://hypf/./src/Hyperfetch.ts","webpack://hypf/./src/utils/append-params.ts","webpack://hypf/./src/utils/create-http-error.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hypf\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hypf\"] = factory();\n\telse\n\t\troot[\"hypf\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Default maximum recommended timeout in milliseconds (adjust as needed)\r\nexport const DEFAULT_MAX_TIMEOUT = 2147483647;\r\n\r\nexport const DEFAULT_BACKOFF_FACTOR = 0.3;\r\nexport const DEFAULT_JITTER_FACTOR = 1;\r\n\r\nexport const isAbortControllerSupported =\r\n  typeof globalThis.AbortController === \"function\";\r\nexport const isReadableStreamSupported =\r\n  typeof globalThis.ReadableStream === \"function\";\r\nexport const isWriteableStreamSupported =\r\n  typeof globalThis.WritableStream === \"function\";\r\nexport const isWebsocketSupported = typeof globalThis.WebSocket === \"function\";\r\nexport const isWebRTCSupported =\r\n  typeof globalThis.RTCPeerConnection === \"function\";\r\nexport const isFormDataSupported = typeof globalThis.FormData === \"function\";\r\nexport const isNode =\r\n  typeof process !== \"undefined\" && process.release.name === \"node\";\r\n","import type {\r\n  HttpRequestFunctions,\r\n  RequestFunction,\r\n  RequestOptions,\r\n  HttpMethodFunction,\r\n} from \"./types/request.ts\";\r\nimport type { Hooks } from \"./types/hooks.ts\";\r\n\r\nimport {\r\n  DEFAULT_BACKOFF_FACTOR,\r\n  DEFAULT_JITTER_FACTOR,\r\n  DEFAULT_MAX_TIMEOUT,\r\n  isAbortControllerSupported,\r\n  isReadableStreamSupported,\r\n  isWriteableStreamSupported,\r\n  isWebRTCSupported,\r\n  isWebsocketSupported,\r\n  isNode,\r\n} from \"./constant.js\";\r\n\r\nimport { appendParams } from \"./utils/append-params.js\";\r\nimport { createHTTPError } from \"./utils/create-http-error.js\";\r\n\r\nconst defaultBackoff = (retryCount: number, factor: number) =>\r\n  Math.pow(2, retryCount) * 1000 * factor; // Exponential backoff, starting from 1 second\r\n\r\nconst defaultJitter = (factor: number) => Math.random() * 1000 * factor; // Randomized delay up to 1 second\r\n\r\n// Expose the AbortController instance through the library interface\r\nconst getAbortController = () =>\r\n  isAbortControllerSupported ? globalThis.abortController : null;\r\n\r\nfunction createRequest(\r\n  baseUrl?: string,\r\n  hooks?: Hooks,\r\n  DEBUG = false\r\n): HttpRequestFunctions {\r\n  // Check if fetch is available (browser environment)\r\n  if (typeof fetch === \"undefined\") {\r\n    throw new Error(\r\n      \"This library is intended for use in the browser environment only.\"\r\n    );\r\n  }\r\n\r\n  const request: RequestFunction = async (\r\n    url = \"\",\r\n    options = {},\r\n    data\r\n  ): Promise<[Error | null, null]> => {\r\n    const {\r\n      method = \"GET\",\r\n      retries = 0,\r\n      backoff = defaultBackoff,\r\n      jitter = false,\r\n      jitterFactor = DEFAULT_JITTER_FACTOR,\r\n      backoffFactor = DEFAULT_BACKOFF_FACTOR,\r\n      timeout = DEFAULT_MAX_TIMEOUT,\r\n      retryOnTimeout = false,\r\n      params,\r\n      headers = {},\r\n      signal,\r\n      ...otherOptions\r\n    } = options;\r\n\r\n    try {\r\n      // Execute pre-request hook\r\n      if (hooks?.preRequest) {\r\n        hooks.preRequest(url, options);\r\n      }\r\n\r\n      const fullUrl = `${baseUrl}${url}`;\r\n\r\n      const reqHeaders = new Headers(headers);\r\n\r\n      // Automatically detect and add Content-Length based on payload length\r\n      const textEncoder = new TextEncoder();\r\n      if (!reqHeaders.get(\"Content-Length\") && data) {\r\n        if (typeof data === \"string\") {\r\n          reqHeaders.set(\r\n            \"Content-Length\",\r\n            String(textEncoder.encode(data).length)\r\n          );\r\n        } else if (\r\n          reqHeaders.get(\"Content-Length\")?.includes(\"application/json\")\r\n        ) {\r\n          reqHeaders.set(\r\n            \"Content-Length\",\r\n            String(textEncoder.encode(JSON.stringify(data)).length)\r\n          );\r\n        }\r\n      }\r\n\r\n      // Set default Content-Type to application/json if not provided\r\n      if (!reqHeaders.get(\"Content-Type\") && data && typeof data === \"object\") {\r\n        if (\r\n          !(((data as { body: FormData })?.body || data) instanceof FormData)\r\n        ) {\r\n          reqHeaders.set(\"Content-Type\", \"application/json\");\r\n        }\r\n      }\r\n\r\n      // Execute pre-timeout hook\r\n      if (hooks?.preTimeout) {\r\n        hooks.preTimeout(url, options);\r\n      }\r\n\r\n      if (isAbortControllerSupported) {\r\n        // Expose the AbortController instance\r\n        globalThis.abortController = new AbortController();\r\n\r\n        // Use the external AbortController instance\r\n        globalThis.abortSignal = signal\r\n          ? signal\r\n          : globalThis.abortController.signal;\r\n      }\r\n\r\n      const timeoutId =\r\n        timeout && isAbortControllerSupported\r\n          ? setTimeout(() => {\r\n              globalThis.abortController.abort();\r\n\r\n              // Execute post-timeout hook\r\n              if (hooks?.postTimeout) {\r\n                hooks.postTimeout(url, options);\r\n              }\r\n            }, timeout)\r\n          : undefined;\r\n\r\n      // Append params to the URL\r\n      const urlWithParams = params ? appendParams(fullUrl, params) : fullUrl;\r\n\r\n      if (isReadableStreamSupported && !isWriteableStreamSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      if (!isReadableStreamSupported && isWriteableStreamSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      if (isReadableStreamSupported && isWriteableStreamSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      // WebRTC is supported, allowing for full duplex communication.\r\n      if (isWebRTCSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n      // WebSockets are supported, and thus full duplex communication is possible.\r\n      if (isWebsocketSupported && isNode) {\r\n        // @ts-expect-error\r\n        otherOptions.duplex = \"half\";\r\n      }\r\n\r\n      const requestBody =\r\n        options.body instanceof FormData\r\n          ? options.body\r\n          : data\r\n          ? JSON.stringify(data)\r\n          : undefined;\r\n\r\n      const requestOptions = {\r\n        method,\r\n        signal: isAbortControllerSupported ? globalThis.abortSignal : null,\r\n        headers: reqHeaders,\r\n        ...otherOptions,\r\n        body: requestBody,\r\n      };\r\n\r\n      if (requestBody instanceof FormData) {\r\n        requestOptions.headers.delete(\"Content-Type\");\r\n      }\r\n\r\n      console.log(requestOptions);\r\n\r\n      const responsePromise = fetch(urlWithParams, requestOptions);\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      const response = await responsePromise;\r\n\r\n      const contentType = response.headers.get(\"content-type\");\r\n\r\n      const responseData =\r\n        contentType && contentType.includes(\"application/json\")\r\n          ? await response.json()\r\n          : await response.text();\r\n\r\n      if (!response.ok) {\r\n        throw createHTTPError(response, responseData);\r\n      }\r\n\r\n      // Execute post-request hook\r\n      if (hooks?.postRequest) {\r\n        hooks.postRequest(url, options, data, [null, responseData]);\r\n      }\r\n\r\n      return [null, responseData];\r\n    } catch (error) {\r\n      // Execute post-request hook for errors\r\n      if (hooks?.postRequest) {\r\n        if (error instanceof Error) {\r\n          hooks.postRequest(url, options, data, [error, null]);\r\n        }\r\n      }\r\n\r\n      if (error instanceof Error) {\r\n        if (error.name === \"AbortError\") {\r\n          console.error(\"Request aborted:\", error);\r\n        } else if (\r\n          retryOnTimeout &&\r\n          error.name === \"TimeoutError\" &&\r\n          retries &&\r\n          retries > 0\r\n        ) {\r\n          const delay =\r\n            jitter && jitterFactor\r\n              ? defaultJitter(jitterFactor)\r\n              : defaultBackoff(\r\n                  retries,\r\n                  backoffFactor ? backoffFactor : DEFAULT_BACKOFF_FACTOR\r\n                );\r\n          if (DEBUG) {\r\n            console.warn(\r\n              `Request timed out. Retrying in ${delay}ms... (Remaining retries: ${retries})`\r\n            );\r\n          }\r\n          // Execute pre-retry hook\r\n          if (hooks?.preRetry) {\r\n            hooks.preRetry(url, options, retries, retries);\r\n          }\r\n          await new Promise((resolve) => setTimeout(resolve, delay));\r\n          const [retryErr, retryData] = await request(\r\n            url,\r\n            { ...options, retries: retries - 1 },\r\n            data\r\n          );\r\n          // Execute post-retry hook\r\n          if (hooks?.postRetry) {\r\n            hooks.postRetry(\r\n              url,\r\n              options,\r\n              data,\r\n              [retryErr, retryData],\r\n              retries,\r\n              retries - 1\r\n            );\r\n          }\r\n          return [retryErr, retryData];\r\n        } else if (options.retries && options.retries > 0) {\r\n          const delay =\r\n            options.jitter && options.jitterFactor\r\n              ? defaultJitter(options.jitterFactor)\r\n              : defaultBackoff(\r\n                  options.retries,\r\n                  options.backoffFactor\r\n                    ? options.backoffFactor\r\n                    : DEFAULT_BACKOFF_FACTOR\r\n                );\r\n          if (DEBUG) {\r\n            console.warn(\r\n              `Request failed. Retrying in ${delay}ms... (Remaining retries: ${options.retries})`\r\n            );\r\n          }\r\n          // Execute pre-retry hook\r\n          if (hooks?.preRetry) {\r\n            hooks.preRetry(url, options, options.retries, options.retries);\r\n          }\r\n          await new Promise((resolve) => setTimeout(resolve, delay));\r\n          const [retryErr, retryData] = await request(\r\n            url,\r\n            { ...options, retries: options.retries - 1 },\r\n            data\r\n          );\r\n          // Execute post-retry hook\r\n          if (hooks?.postRetry) {\r\n            hooks.postRetry(\r\n              url,\r\n              options,\r\n              data,\r\n              [retryErr, retryData],\r\n              options.retries,\r\n              options.retries - 1\r\n            );\r\n          }\r\n          return [retryErr, retryData];\r\n        }\r\n      }\r\n\r\n      if (error instanceof Error) {\r\n        return [error, null];\r\n      }\r\n\r\n      return [null, null];\r\n    }\r\n  };\r\n\r\n  const httpMethodFunction: HttpMethodFunction =\r\n    (url: string, options: RequestOptions = {}) =>\r\n    (method = \"GET\", additionalOptions = {}, data) => {\r\n      return request(url, { method, ...options, ...additionalOptions }, data);\r\n    };\r\n\r\n  return {\r\n    get: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"GET\", options, data),\r\n    post: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"POST\", options, data),\r\n    put: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"PUT\", options, data),\r\n    delete: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"DELETE\", options, data),\r\n    patch: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"PATCH\", options, data),\r\n    options: (url, options, data) =>\r\n      httpMethodFunction(url, options)(\"OPTIONS\", options, data),\r\n    getAbortController,\r\n  };\r\n}\r\n\r\nexport default { createRequest };\r\n","export function appendParams(\r\n  url: string,\r\n  params?: Record<string, string | number>\r\n): string {\r\n  if (!params) return url;\r\n\r\n  const urlWithParams = new URL(url);\r\n  Object.entries(params).forEach(([key, value]) =>\r\n    urlWithParams.searchParams.append(key, String(value))\r\n  );\r\n\r\n  return urlWithParams.toString();\r\n}\r\n","export function createHTTPError(response: Response, responseData: Response) {\r\n  const code = response.status || response.status === 0 ? response.status : \"\";\r\n  const title = response.statusText || \"\";\r\n  const status = `${code} ${title}`.trim();\r\n  const reason = status ? `status code ${status}` : \"an unknown error\";\r\n  const error = new Error(reason);\r\n\r\n  error.name = \"HTTPError\";\r\n\r\n  (error as any).response = response;\r\n  (error as any).data = responseData;\r\n\r\n  return error;\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","DEFAULT_MAX_TIMEOUT","DEFAULT_BACKOFF_FACTOR","DEFAULT_JITTER_FACTOR","isAbortControllerSupported","globalThis","AbortController","isReadableStreamSupported","ReadableStream","isWriteableStreamSupported","WritableStream","isWebsocketSupported","WebSocket","isWebRTCSupported","RTCPeerConnection","isNode","FormData","process","release","name","defaultBackoff","retryCount","factor","Math","pow","defaultJitter","random","getAbortController","abortController","createRequest","baseUrl","hooks","DEBUG","fetch","Error","request","url","options","data","method","retries","backoff","jitter","jitterFactor","backoffFactor","timeout","retryOnTimeout","params","headers","signal","otherOptions","preRequest","fullUrl","reqHeaders","Headers","textEncoder","TextEncoder","set","String","encode","length","includes","JSON","stringify","body","preTimeout","abortSignal","timeoutId","setTimeout","abort","postTimeout","undefined","urlWithParams","URL","entries","forEach","searchParams","append","toString","appendParams","duplex","requestBody","requestOptions","delete","console","log","responsePromise","clearTimeout","response","contentType","responseData","json","text","ok","status","statusText","trim","error","createHTTPError","postRequest","delay","warn","preRetry","Promise","resolve","retryErr","retryData","postRetry","httpMethodFunction","additionalOptions","post","put","patch"],"sourceRoot":""}